<!DOCTYPE html>
<html>
<head>
    <title>磁性粒子效果</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // 设置画布尺寸
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 粒子参数
        const particleSize = 3; // 粒子大小，约1mm
        const particleMargin = 1;//粒子间距
        const repulsionRadius = 115;//排斥作用范围
        const repulsionForce = 1.7;//排斥力强度
        const friction = 0.15;//运动摩擦力
        const returnSpeed = 0.01;//返回原位的速度

        // 存储粒子和鼠标位置
        let particles = [];
        let mouse = { x: -1000, y: -1000 };

        // 粒子类
        class Particle {
            constructor(x, y) {
                this.originalX = x;
                this.originalY = y;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.color = Math.random() > 0.5 ? '#fff' : '#ccc';
            }

            update() {
                // 计算鼠标排斥力
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < repulsionRadius) {
                    const angle = Math.atan2(dy, dx);
                    const force = (repulsionRadius - distance) / repulsionRadius * repulsionForce;
                    
                    this.vx += Math.cos(angle) * force;
                    this.vy += Math.sin(angle) * force;
                }

                // 返回原位置的力
                const returnX = (this.originalX - this.x) * returnSpeed;
                const returnY = (this.originalY - this.y) * returnSpeed;
                
                this.vx += returnX;
                this.vy += returnY;

                // 应用摩擦
                this.vx *= (1 - friction);
                this.vy *= (1 - friction);

                // 更新位置
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, particleSize/2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 初始化粒子排列（圆形）
        function initParticles() {
            particles = [];
            const centerX = canvas.width/2;
            const centerY = canvas.height/2;
            const radius = 150;
            
            for (let r = 0; r < radius; r += particleSize + particleMargin) {
                const circumference = 2 * Math.PI * r;
                const particlesCount = circumference / (particleSize + particleMargin);
                
                for (let i = 0; i < particlesCount; i++) {
                    const angle = (i / particlesCount) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    particles.push(new Particle(x, y));
                }
            }
        }

        // 动画循环
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            requestAnimationFrame(animate);
        }

        // 鼠标移动监听
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // 启动
        initParticles();
        animate();
    </script>
</body>
</html>