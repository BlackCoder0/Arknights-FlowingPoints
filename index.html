<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // 设置画布尺寸
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // 点阵配置
        const config = {
            pointRadius: 2,          // 点半径
            spacing: 10,             // 点间距
            mouseRadius: 80,         // 鼠标影响范围
            maxDistance: 20,         // 最大位移距离
            friction: 0.1            // 位置恢复速度
        };
        
        // 生成点阵
        const points = [];
        for(let x = 0; x < canvas.width; x += config.spacing) {
            for(let y = 0; y < canvas.height; y += config.spacing) {
                points.push({
                    x: x,
                    y: y,
                    dx: 0,
                    dy: 0
                });
            }
        }
        
        // 鼠标位置跟踪
        let mouseX = null;
        let mouseY = null;
        
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouseX = null;
            mouseY = null;
        });
        
        // 动画循环
        function animate() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            points.forEach(point => {
                // 计算原始位置偏移
                let dx = 0;
                let dy = 0;
                
                // 计算鼠标影响
                if (mouseX !== null && mouseY !== null) {
                    const distance = Math.hypot(mouseX - point.x, mouseY - point.y);
                    if (distance < config.mouseRadius) {
                        const angle = Math.atan2(point.y - mouseY, point.x - mouseX);
                        const force = (config.mouseRadius - distance) / config.mouseRadius;
                        dx = Math.cos(angle) * force * config.maxDistance;
                        dy = Math.sin(angle) * force * config.maxDistance;
                    }
                }
                
                // 应用平滑过渡
                point.dx += (dx - point.dx) * config.friction;
                point.dy += (dy - point.dy) * config.friction;
                
                // 绘制点
                ctx.beginPath();
                ctx.fillStyle = '#fff';
                ctx.arc(
                    point.x + point.dx,
                    point.y + point.dy,
                    config.pointRadius,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>